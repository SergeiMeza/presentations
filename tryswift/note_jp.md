

私の名前はnoppeです。
今日は初めての英語のプレゼンテーションです。よろしくお願いします。
DeNAという会社でiOSアプリエンジニアをしています。

---

今日話をするのは、Swiftのimportについてです。
import宣言をみたことが無い人はいないでしょう。
XcodeからSwiftファイルを作ると、UIKitがimportされているファイルが自動的に作られるからです。

---

importについて振り返りましょう。
import宣言を使うと、外部のシンボルにアクセス出来るようになります。
例えば、UILabelやUIViewControllerはUIKitのコンポーネントです。
なので、import UIKitと書けばこれらのコンポーネントを利用することができます。

---

もちろん、import宣言を行わないとコンパイルする事ができません。

---

さて、普段何気なく書いているimportですが、いくつかのオプションが存在する事を知っていますか？

---

実はこのようなオプションを使うことができます。
この仕様は、Swiftのドキュメントから見つけることができます。
普段書いているimport文よりも複雑であることが分かります。
それではそれぞれのtokenについて説明します。

---

まずはattributesについて見てみましょう
attributesは、シンボルの取り込み方を指定するオプションです。
arttibuteは書いてもいいですし、書かなくても良いです
現在Swiftには@testableと@_exportedの2つが存在します。

---

testableはテストで利用するattributesです。
@testableを付けると、internalメソッドにもアクセス出来るようになります。
テストのために元のコードを変更する必要がなくなります。

---

@_exportedは自分自身のコードのようにシンボルをインポートします。
例えば、SwiftでUmbrellaFrameworkを作る際に利用できます。
アンダースコアで始まっているのはプライベートな宣言です。
非推奨なので、開発時の利用に留める事をおすすめします。
ABI安定化に対して影響を与える可能性もあります。

---

次にサブモジュールの指定方法を見てみましょう。
submoduleを指定すると、submoduleの実装をimportすることができます。
例えばSceneKitでは、サブモジュールを上手に利用しています。
SceneKitはModelIOのクラスからSceneを作ったり、SceneからModelを作る拡張があります。
しかし、これらの拡張をSceneKitに含むとSceneKitはModelIOの利用に関わらずModelIOに依存することになります。
そこで、SceneKitはModelIOの拡張をサブモジュールとして定義しています。
サブモジュールを指定してimportすることで、SCNSceneのコンストラクタが増えることが確認できます。

---


サブモジュールのあるフレームワークを作るには、modulemapでexplictを使って宣言します。
Swiftは単一のモジュールとして定義されるため、サブモジュールを宣言できるのはObjective-Cのフレームワークだけです。
あなたはSwiftでモジュールを書くでしょうから、実際は、自分で作ったライブラリでこの宣言をすることは多く無いかもしれません。

---

次に3つ目の記法を紹介します。
kindを指定すると、指定した要素を取り込みます。
kindを指定した場合、moduleの後に指定するのはサブモジュール名ではありません。要素の実装名を指定します。
例えばUserというClassだけをimportしたい場合は、モジュール名の後にUserと記述します。

---

kindはstruct, class, enum, protocol, typealias, func, let, varが指定できます。
それぞれSwiftでみたことのある要素と同じ意味です。

---

ここでは２つの注意点があります。
一つは、classやsturctをimportする際です。
classやstructを指定した場合は、実装されたメソッドやプロパティも含まれます。
ここで指定するletやfuncはtop-levelの実装を指します。

---

二つ目はオーバーロード関数に関してです。
同名の関数をswiftでは宣言することができます。
この場合は、個別にimportすることはできません。
両方のfunctionがimportされることになります。

---

kindを使ったimportを利用する例を紹介します。
異なるモジュールで同名の関数を宣言している時にこの記法は必要になります。
例えば、CatモジュールとFoxモジュールはprintEmojiという関数を持っています。
printEmojiはモジュール名の動物を出力します。
これらのモジュールを両方importすると、エラーが発生します。
kindを使ったimportは、優先的にメソッドを見つけます。

---

さて、importのオプションについて紹介しました。
少し使いどころが難しいですね。
他に分かりやすく良い点はあるでしょうか？

---

ビルド時間を計測してみましょう。
テンプレートエンジンのgybを使って、10000000個のメソッドを作りました。
これをKindを指定した場合としない場合で比較します。
計測はリリースビルドで行いました。

---

結果はほとんど変わりませんでした。

---

では、バイナリサイズは変わるでしょうか？

---

先ほどのビルドのサイズを比較してみます。
これも変わりませんでした。
そして、バイナリファイルのmd5はそれぞれ同じでした。
つまり、どのような記法であっても、Swiftコンパイラが最適化を行うので結果は同じになるということです。

---

ProsConsです。
この表を見ればわかる通り、名前空間の問題がなければimportを詳細に記述する必要性は無いということです。

---

なので、これまで通りコードを書きましょう。
以上になります。ありがとうございました。

---
