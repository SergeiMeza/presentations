slidenumbers: true
autoscale: true

<!-- Header -->

# ランタイムデバッグのススメ

## iOSDC2021 TrackA Day2

### noppe / iOS app developer

^ おはようございます、iOSDC最終日の朝ということで皆さんお疲れさまです。
^ このセッションではランタイムデバッグのススメというタイトルで、開発テクニックに関する話をしていきます。

---

# noppe

![right](profile.png)

- 株式会社ディー・エヌ・エー
  - ソーシャルライブPococha
- iOSDC 4年目
- 個人アプリ開発
  - バーチャル自撮りアプリvear

^ まずは軽く自己紹介をさせてください。
^ キツネのアイコンで活動しているnoppeと言います。
^ 株式会社ディー・エヌ・エーでPocochaというアプリのiOSアプリエンジニアをしています。
^ iOSDCはありがたいことに4年連続で採択して頂いていて、毎年Pocochaに関わる少しコアな話をしているのですが、今回は比較的ライトなセッションになります。
^ お気軽に聞いていただければと思います。
^ また、個人でバーチャルアバターの自撮りアプリのvearを開発しています。
^ 今日話す開発テクニックは、Pocochaとvearの両方で採用しているものなので小さなアプリから大きなアプリまで参考になると思います。

---

![fit](cfp.png)

^ さて、早速ですがタイトルにもなっているランタイムデバッグという言葉なのですが

---

![fit](NotFound.png)

^ これは存在しない言葉でした。すいません。

---

[.slidenumber: false]

![fit](NotFound.png)

存在しない単語なので…

# 定義

実行中のアプリで、デバッグをすること[^1]

≒ 実機テスト

とします。

[^1]:このセッションの中での定義

^ なので言葉の定義が必要なのですが、このセッションの中では「実行中のアプリでデバッグをする事」とさせてください。
^ 例えば、Testflightのベータ版アプリをプレイすることも、この定義に含まれます。
^ ここから分かるように、ランタイムデバッグとは皆さんが普段開発の中で行っている、一般的なデバッグ操作の事を指しています。

---

# 対象

- アプリエンジニア
- QA担当者
- デザイナー
...etc

#### ※ 実機デバッグを推奨するセッションではありません。実機デバッグせざる得ないケースという前提でお聞きください。

^ ランタイムデバッグをするテスターというのは広く、エンジニアをはじめ、QA担当者やアニメーションを実機で確認するデザイナーもこれらに含まれます。
^ また、注意して欲しいのですが、今回のセッションではランタイムデバッグが開発においてどのように作用するのかという話をしますが、これはテスト書くのをやめて実機デバッグしようぜという話ではないので、あくまで実機デバッグせざる得ないケース。
^ これはハードウェアに依存することだったり、事業フェーズが要因にだったりと色々あると思いますが、そういう前提でお聞きいただければと思います。

---

[.code-highlight: all]
[.code-highlight: 3]
[.code-highlight: 6-10]

## 一般的な開発フロー

```
1. コーディング・仕様策定・etc
2. コンパイル
3. シミュレータ・デバイス実行・ライブプレビュー
4. UnitTest
5. 結合テスト
6. CI
7. QA
8. ベータテスト
9. リリーステスト
10. 本番テスト
```

^ 開発フローを振り返ると、ランタイムデバッグがアプリ開発の中の多くのステップで実施されていることが分かります。
^ これは、開発からリリースまでのステップを簡易的に分けたものです。
^ 例えば、アプリの開発フローの中で、最初にランタイムデバッグを行うのはコンパイル直後の3番のステップです。
^ このステップでは、アプリのレイアウトやアニメーションといったUnitテストでテストし難い部分をプレビューしながら開発を進めます。
^ 最近ではSwiftUIのプレビューがXcodeで行えるようになった為、1~3のイテレーションはかなり高速に回るようになってきましたね。
^ また、7以降では、アプリはエンジニアの手を離れてadhocやTestFlightといった手段でテスターに届けられます。

---

# ランタイムデバッグの特徴

- 人間が手作業で行う
- エンジニアが行うとは限らない
- 開発ステップの多くで実施される

^ このようにランタイムデバッグは多様な人の手で行われ、そして開発の大きな時間を割いて行われています。
^ これはUnitTestで検証し難い箇所を確認出来る反面、人の手が関わるとトレードオフになるものも存在します。

---

[.build-lists: true]

# ランタイムデバッグのトレードオフ

1. 時間的コスト
   - ≒金銭的コスト
   - ≒事業リスク
2. 人による感覚のブレ
   - 何を良し悪しとするか

^ トレードオフになる１つは時間です。
^ これは言うまでもないですが、人間の操作は非常に時間がかかります。
^ それによって、金銭的なコストもかかりますし、競合のリリースサイクルに負ける事業的なリスクもあります。
^ ２つ目は人による感覚のブレです。人によってスクロールの滑らかさを問題とする人もいれば、そうでない人もいます。
^ これらの課題意識のすり合わせはどんなに定義したとしても、どこかで起きているでしょう。
^ この２つの課題感について、エンジニアが工夫出来ることを今日はお話しします。

---

## 時間的コストの改善

^ まずは一つ目の時間的コストの改善について

---

[.code-highlight: all]
[.code-highlight: 3-6]

## 検証速度の改善

### ランタイムデバッグのフロー

```
1. コンパイル
2. 転送
3. 環境の確認
4. 画面までの操作
5. 動作検証
```

これらのどこにどんな時間がかかっているのかを知る必要がある。

^ 時間的コストを改善するには、ランタイムデバッグにおいて何が時間がかかっているのかを知る必要があります。
^ 画面に映っているのは、ランタイムデバッグの目的である動作確認に辿り着くまでのステップになります。
^ コンパイルや転送の高速化は他のセッションでも話されている議題かと思いますので、ここでは3番以降をランタイムデバッグを上手に使って改善をしてみます。

---

## 検証速度の改善

### 3.環境の確認

- バージョン番号、ビルド番号
  - ログを見る
- OSのバージョン、モデル
  - 設定アプリから参照
- ビルドの最終担当者
...etc

![right](unknown_phone.png)

^ ランタイムデバッグで一番最初に行うのは、現在動作している環境が想定しているものであるかを確認することです。
^ このステップを間違えると、ここから先の検証が無意味なものになってしまいます。
^ この確認作業は意外と時間がかかるものです。例えばOSバージョン一つ見るのに、iOSの場合は設定から2タップが必要になります。
^ 自分の関わったプロダクトでは、バージョンやビルド番号を毎回bitriseを開いて見にいっているケースもありました。

---

### 3.環境の確認

A. アプリの中で見れるようにし、操作を省く

なんでもかんでも表示せず、必要な情報か見極める

- adhocビルドを触っている人にヒアリング
  - 確認にコミュニケーションが必要なものがないか
  - 手作業による操作が必要なものがないか

![right fit](env.png)

^ これらの情報は、アプリの中で見れるようにすることで無駄な操作を省く事が出来ます。
^ ただし、なんでもかんでも表示しないようにしましょう。
^ よくあるケースとして、アプリのメモリ残量やストレージ容量などを事細かに表示している事がありますが、逆に情報を探す時間がかかってしまう事があります。
^ 詳細に表示する画面が必要な場合は別で用意しつつ、ダッシュボード的に重要な情報に絞った画面を用意しましょう。開発者向けの画面でもUIUXを意識することが大切です。
^ 重要な情報の定義はサービスによって異なると思いますので、実際にadhocビルドを触っている人にヒアリングすることをお勧めします。

---

[.slidenumber: false]

### デバッグメニュー

- 開発関係者向けの特殊な画面

- 非エンジニア[^2]にとって、非常に強力な存在

[^2]:実装の変更が出来ないテスター

![right fit](debugmenu_in_settings.png)

^ また、このような開発でのみ必要な情報を表示する先として、デバッグメニューを用意することをおすすめします。
^ デバッグメニューは、本番のアプリには表示されない特殊な画面です。
^ ゲームの開発などでよく見かける機能ですが、アプリの開発においても有効な手法です。
^ そして、何よりも自分でアプリの挙動を弄れるエンジニア以外にとっては、デバッグメニューは非常に強力な存在になります。

---

### デバッグメニューの実装

1. 適当な画面を用意する
2. 本番で呼べないようにする

![right](hammer.png)

^ デバッグメニューを実装するために必要な事はたったの２つです。
^ 一つは、適当な画面を用意すること。まずは先ほど出ていたOSやアプリバージョンが確認できるViewControllerがあれば良いでしょう。
^ そして、それを本番では表示しないことです。

---

[.code-highlight: all]
[.code-highlight: 6-9]

### デバッグメニューの実装

```swift
func onTapSettings(section: Section) {
    switch section {
        case .general:
            ...
        #if DEBUG // #endifまでのコードは本番に含まれない
        case .debugMenu:
            let vc = DebugMenuViewController()
            present(vc, animated: true)
        #endif
    }
}

#if DEBUG
final class DebugMenuViewController: UITableController {
    ...
}
#endif

```

![original](code_background.png)

^ コードに落としてみると、このようになります。
^ ハックされたiPhoneでは本番環境で直接デバッグメニューを呼び出すことが出来てしまいます。
^ そのため、このようにDEBUGフラグを使って実行バイナリから実装を取り除く必要があります。

---

### デバッグメニューの実装

開発用機能をモジュール化し、安全に分離するには

|||
|---|--:|
|Swift Package中心のプロジェクト構成とその実践|Day2 TrackC 14:50|
|大規模なアプリのマルチモジュール構成の実践|Day2 TrackA 11:30|

^ デバッグ機能を一つのモジュールにまとめたいケースもあると思います。
^ その場合、本番のアプリにリンクされないようにするなどの工夫が必要になります。
^ この方法については、この後の２つのセッションにヒントがあると思いますので見てみることをオススメします。

---

## 検証速度の改善

### 再ビルド・再インストールを伴う環境

- 接続先サーバーの設定
- チュートリアル表示のリセット
- キャッシュの削除

^ さて、話を元に戻します。
^ 環境の中には、アプリを再ビルドしたり、再インストールしないと変更できないものがあるかもしれません。
^ よくあるのは、開発とadhocでサーバーを分けているケースです。ビルドによって環境を固定すると、一時的に切り替えたい時に再ビルド・インストールが必要になります。
^ 特にiOS14からはアプリ削除時のダイアログが2タップ必要なので、なるべく回数を減らしたいところです。

---

## 検証速度の改善

### 再ビルド・再インストールを伴う環境

デバッグメニューから設定・実行できるようにする

![right fit](update_settings.png)

^ これらの課題は、デバッグメニューから直接選択・実行出来るようにしておくことで解決します。
^ つまりデバッグメニューは、参照だけではなく変更も行えるということです。
^ ここで少しデバッグメニューのUXについても触れておきましょう。

---

[.slidenumber: false]

### デバッグメニューのUX

- テスターは実装を知らないのでEasyに寄せる
  - 再起動が必要であれば、`exit(0)`でアプリを終了させる
  - 実行に順序が必要なものなどはまとめる、コメントを記述する
  - 無闇に実行してはいけないものは文字色を変える
- 整頓する
  - なんでもかんでも作らない、使われなくなったら消す
  - 担当者を明確にしたり、探しやすくする

^ 常に意識しなくてはならないのは、テスターは実装を知っているとは限らない点です。
^ 再起動が必要なものがあればその旨を表示してアプリを殺したり、強い権限のものは色を変えたりしましょう。
^ そして、機能を整頓するのも重要です。
^ アプリの仕様が増えるほどデバッグメニューは増えますが、それでは目的の機能を探す時間がかかってしまいます。
^ 担当者や利用シーンでまとめたりして探しやすくしましょう。

---

## 検証速度の改善

### 画面までの操作

- 画面遷移が多い
- 通信や重い処理が挟まるほど時間がかかる
- 遷移条件が厳しい

### Hint

- 起動から`onAppear()`や`viewDidAppear()`までの時間を計測する

![right fit](nested.png)

^ 環境の準備が出来ると、いよいよアプリを触っていくわけですが該当の画面までが遠いというケースがよくあります。
^ 奥まった場所にある画面や、サーバから特定条件が返ってこないと遷移できない画面などがこれにあたります。
^ テスターが起動してからonAppearに達するまでの時間のログを取っておくと、時間のかかっている画面が特定できます。

---

## 検証速度の改善

### 画面までの操作

1. デバッグメニューから直接飛べるようにする
2. URLスキームから起動する

![right fit](screen_jump.png)

^ これらの解決策として、デバッグメニューから直接ViewControllerを呼び出すことで、操作時間を短縮する事ができます。
^ また、アプリ全体でルーティングが施されているアプリの場合はURLスキームを叩いて遷移することもできます。
^ 特に限定的な状況下でしか開けない画面に有効

---

### アプリ自身がURLスキームを使って再起動するTIPS



---

## 検証速度の改善

### 動作検証

- 時短し難い箇所
- フィールの検証
  - アニメーション・ジェスチャー・感覚フィードバック

### 解決策

そもそも手作業の検証が必要か再考する
パラメータの調整はランタイムで出来るようにする

^ さて、最終ステップがいよいよ動作検証です。
^ 動作検証では、なるべくアプリの中でトライアンドエラーを出来るように意識します。
^ 特にデザイナーなどに動作のフィールをチェックしてもらうタイミングではこの手法は有効です。

---

## 検証速度の改善

### 実際のケース

![right fit](FindMy.png)

Find Myでは、パーティクルの数や背景のブラー濃度を調整できる機能が存在していた。

^ 例えば、AppleのFindMyアプリではAirTagの探索をする画面にデバッグメニューが存在していてエンドユーザーが呼び出せる時期がありました。
^ ここでは画面内のカメラ解像度やブラー濃度が調整可能で、実際の動作を見ながらフィールを改善していたと推測できます。
^ 余談ですが、このように時々デバッグメニューはユーザーが呼び出せる事があるので積極的に触って、どんな機能が実際の現場で検証されているのかを知るのも良い勉強になります。

---

### Recap

- デバッグメニューを活用して、アプリで検証を完結することで検証時間を短縮する

^ 検証速度の改善は、

---

## 人による感覚のブレ

人間が触る以上、感覚の違いが起こりうる
定性的な情報が集められる反面、

- 多いのは見過ごし
  - レイアウト・アニメーションのグリッチ
- 定性的な感覚
  - 重い・遅い

^ 先ほど言った通り、実機検証はフィールの側面が強い。

---

## 精度

### 見過ごしや感覚的なもの

ログを見ても分からないことが多い
RPScreenRecorderを使うことで操作の15秒前までを記録することができる

```swift
RPScreenRecorder.shared().startClipBuffering()
RPScreenRecorder.shared().exportClip(to: url, duration: 5)
RPScreenRecorder.shared().stopClipBuffering()
```

^ 違和感があったら、すぐに送ってもらう。exportしたビデオクリップをSlackやgithub issueに投稿するところまでアプリ内で完結するといいね
^ 動画を見れば、何を持ってそう思ったのか振り返れる

---

## 精度

### 操作のブレ

- 5秒ごとにコメント送信を10分繰り返す
- 端末を15度づつ傾ける

操作の自動化をする

---

## 精度Recap

- TODO

---

## 関心を上げる

チームサイズが大きくなるほど、個々の関心は自分の作業に向きがち
詳細な分析をせずとも品質指標をアプリ上で見えるようにする
- fps
- 熱
- URLセッション数

画面を占有しないように注意

---

## 関心を上げる Recap

- TODO

---

# デバッグメニューを導入するには

---

# デバッグメニューを導入するには

- 自分で書く
- Settings.bundle
- ライブラリを導入する

---

# 自分で書く

## メリット

サービスに最適化したデバッグメニューが作れる

## デメリット

なるべくサービスの体験にフォーカスした方が良い

^ これは持論ですが

---

# Settings.bundle

## メリット

簡単に作れる
設定変更時に自動でアプリが再起動する

## デメリット

自由度が少ない

---

# ライブラリを導入する

## メリット

簡単に作れる

## デメリット

アプリと別のレイヤーで動作する

---

# noppefoxwolf/DebugMenu

- vear、Pococha、NAHの全てで採用しています
- 過去にvineは画面上にデバッグメニューを表示できる機能を入れていた
- アプリ全体で常に利用できるのが特徴

---

# DEMO

---

# デバッグメニューのコツ

- 担当者・機能ごとにまとめる
- 本番ビルドに含めない
- 要らない機能を入れない

---

- Recap（要点の繰り返し）
    - アプリ開発において、ランタイムデバッグの存在は開発効率を向上させることに貢献する
    - デバッグ機能もチームメンバーに対する製品の開発。ヒアリングを含め気を抜かずにやる
    - 基本はUnitTest
- サマリ（つまり）
    - 内向きの機能開発もエンジニアの仕事の一部

---

# More Information

- ターゲット分けについて
- as

---


# Thanks

---

メモ

検証条件画面のbefore-after　必要なのだけ切り出した画面を作る